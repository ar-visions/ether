#ifndef _ETHER_
#define _ETHER_

/// start-trim
#include <A>
/// end-trim

/// @brief the ether should be considered mysterious, and magical.
/// to make effective debuggable LL code, one has to employ multiple 
/// APIs simultaneously (IR & DBG) and its easy for that to take 
/// over the syntax

/// we internalize LLVM here, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct ether*       ether;
typedef struct model*       model;
typedef struct member*      member;
typedef struct record*      record;
typedef struct node*        node;
typedef struct function*    function;

#define comparison_schema(X,Y) \
    enum_value_v(X,Y, equals, 32) \
    enum_value  (X,Y, not_equals) \
    enum_value  (X,Y, u_greater_than) \
    enum_value  (X,Y, u_greater_than_e) \
    enum_value  (X,Y, u_less_than) \
    enum_value  (X,Y, u_less_than_e) \
    enum_value  (X,Y, s_greater_than) \
    enum_value  (X,Y, s_greater_than_e) \
    enum_value  (X,Y, s_less_than) \
    enum_value  (X,Y, s_less_than_e)
declare_enum(comparison)

#define token_schema(X,Y) \
    i_prop      (X,Y,  required, cstr,      chars) \
    i_prop      (X,Y,  public,  sz,         len) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  num,        indent) \
    i_prop      (X,Y,  public,  A,          literal) \
    i_prop      (X,Y,  public,  model,      namespace) \
    i_method    (X,Y,  public,  AType,      get_type) \
    i_method    (X,Y,  public,  sz,         len) \
    i_method    (X,Y,  public,  string,     location) \
    i_method    (X,Y,  public,  bool,       eq,  cstr) \
    i_method    (X,Y,  public,  num,        cmp, cstr) \
    i_cast      (X,Y,  public,  cstr) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  compare) \
    i_override  (X,Y,  cast,    string) \
    i_override  (X,Y,  cast,    bool)
#ifndef token_intern
#define token_intern
#endif
declare_class(token)


#define interface_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(interface)


#define reference_schema(X,Y) \
    enum_value(X,Y, value) \
    enum_value(X,Y, pointer) \
    enum_value(X,Y, constant)
declare_enum(reference)


#define model_schema(X,Y)\
    i_prop    (X,Y, required,   ether,            mod) \
    i_prop    (X,Y, public,     token,            name) \
    i_prop    (X,Y, intern,     array,            aliases) \
    i_prop    (X,Y, required,   model,            src) \
    i_prop    (X,Y, public,     reference,        ref) \
    i_prop    (X,Y, public,     object,           shape) \
    i_prop    (X,Y, public,     bool,             is_map) \
    i_prop    (X,Y, public,     bool,             is_array) \
    i_prop    (X,Y, public,     i64,              element_count) \
    i_prop    (X,Y, public,     i64,              top_stride) \
    i_prop    (X,Y, public,     array,            strides) \
    i_prop    (X,Y, public,     bool,             is_user) \
    i_prop    (X,Y, public,     sz,               size) \
    i_prop    (X,Y, public,     sz,               alignment) \
    i_prop    (X,Y, public,     model,            rtype) \
    i_prop    (X,Y, public,     map,              members) \
    i_prop    (X,Y, public,     path,             from_include) \
    i_prop    (X,Y, public,     array,            body) \
    i_prop    (X,Y, intern,     LLVMScope,        scope) \
    i_prop    (X,Y, intern,     LLVMTypeRef,      type) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,  debug) \
    i_prop    (X,Y, intern,     model,            ptr) \
    i_prop    (X,Y, public,     bool,             finalized) \
    i_prop    (X,Y, intern,     model,            init_top) \
    i_prop    (X,Y, public,     function,         fn_init) \
    i_method  (X,Y, public,     function,   initializer) \
    i_method  (X,Y, public,     model,      pointer) \
    i_method  (X,Y, public,     bool,       has_scope) \
    i_method  (X,Y, public,     none,       process_finalize, member) \
    i_method  (X,Y, public,     model,      alias,              object, reference, array) \
    i_method  (X,Y, public,     none,       finalize, member) \
    i_method  (X,Y, public,     member,     convertible,   model) \
    i_method  (X,Y, public,     member,     castable,      model) \
    i_method  (X,Y, public,     member,     constructable, model) \
    i_override(X,Y, cast,       string) \
    i_override(X,Y, method,     init)
#ifndef model_intern
#define model_intern isize(model)
#endif
declare_class(model)

#define arguments_schema(X,Y) \
    i_prop    (X,Y, public, array,    args) \
    i_prop    (X,Y, public, bool,     is_ext) \
    i_prop    (X,Y, public, model,    ext_type) \
    i_method  (X,Y, public, sz,       len) \
    i_method  (X,Y, public, object,   get, num) \
    i_method  (X,Y, public, none,     push, member) \
    i_method  (X,Y, public, member,   pop) \
    i_override(X,Y, method, init)
#ifndef arguments_intern
#define arguments_intern isize(arguments)
#endif
declare_mod(arguments, model)


#define format_attr_schema(X,Y) \
    i_prop(X,Y, required, string, type) \
    i_prop(X,Y, public,   i32,    format_index) \
    i_prop(X,Y, public,   i32,    arg_index)
#ifndef format_attr_intern
#define format_attr_intern isize(format_attr)
#endif
declare_class(format_attr)


#define function_schema(X,Y) \
    i_prop(X,Y, public,     bool,                   is_cast) \
    i_prop(X,Y, public,     bool,                   is_global_ctr) \
    i_prop(X,Y, public,     bool,                   is_init) \
    i_prop(X,Y, public,     bool,                   va_args) \
    i_prop(X,Y, public,     arguments,              args) \
    i_prop(X,Y, public,     record,                 payload) \
    i_prop(X,Y, public,     bool,                   export) \
    i_prop(X,Y, public,     model,                  record) \
    i_prop(X,Y, public,     model,                  imdl) \
    i_prop(X,Y, public,     bool,                   single_expr) \
    i_prop(X,Y, public,     member,                 target) \
    i_prop(X,Y, public,     member,                 main_member) \
    i_prop(X,Y, public,     AFlag,                  function_type) \
    i_prop(X,Y, intern,     format_attr,            format) \
    i_prop(X,Y, intern,     LLVMBasicBlockRef,      entry) \
    i_prop(X,Y, intern,     LLVMValueRef,           value) \
    i_prop(X,Y, intern,     LLVMTypeRef*,           arg_types) \
    i_prop(X,Y, intern,     num,                    arg_count) \
    i_method(X,Y, public,   none,                   use) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, finalize)
#ifndef function_intern
#define function_intern isize(function)
#endif
declare_mod(function, model)


#define statements_schema(X,Y) \
    i_override(X,Y, method, init)
#ifndef statements_intern
#define statements_intern isize(statements)
#endif
declare_mod(statements, model)

typedef struct schematic* schematic;

// for each field, f_* name-bound class, enum or primitive
#define record_schema(X,Y) \
    i_prop    (X,Y, public, record, parent) \
    i_prop    (X,Y, public, schematic, schema) \
    i_override(X,Y, method,         finalize) \
    i_override(X,Y, method,         init)
#ifndef record_intern
#define record_intern
#endif
declare_mod(record, model)


#define schematic_schema(X,Y) \
    i_prop    (X,Y, public, record,     mdl) \
    i_prop    (X,Y, public, string,     namespace) \
    i_prop    (X,Y, public, interface,  access)
#ifndef schematic_intern
#define schematic_intern isize(schematic)
#endif
declare_class(schematic)


#define class_schema(X,Y)
#ifndef class_intern
#define class_intern
#endif
declare_mod(class, record, model)

#define structure_schema(X,Y)
#ifndef structure_intern
#define structure_intern
#endif
declare_mod(structure, record, model)

#define enumerable_schema(X,Y)
#ifndef enumerable_intern
#define enumerable_intern
#endif
declare_mod(enumerable, record, model)

#define uni_schema(X,Y)
#ifndef uni_intern
#define uni_intern
#endif
declare_mod(uni, record, model)


/// the base helps us require the two args we need for nodes
/// we are also coupling type along inside node, and this must be set properly with value macro
/// all node values must contain its ether def.
/// otherwise we are performing hash lookups, which is more complex and slower, 
/// with less data stored
#define node_schema(X,Y)\
    i_prop    (X,Y, public,     token,                  name) \
    i_prop    (X,Y, public,     ether,                  mod) \
    i_prop    (X,Y, required,   model,                  mdl) \
    i_prop    (X,Y, public,     object,                 literal) \
    i_prop    (X,Y, public,     num,                    line) \
    i_prop    (X,Y, public,     num,                    column) \
    i_prop    (X,Y, public,     bool,                   loaded) \
    i_prop    (X,Y, intern,     LLVMValueRef,           value)
#ifndef node_intern
#define node_intern isize(node)
#endif
declare_class(node)

// if ref is set, its a reference to a member with type definition (model, struct, ref)
#define member_schema(X,Y) \
    i_prop    (X,Y, public,     interface,              access) \
    i_prop    (X,Y, public,     member,                 target_member) \
    i_prop    (X,Y, public,     record,                 target_record) \
    i_prop    (X,Y, public,     bool,                   registered) \
    i_prop    (X,Y, public,     ether,                  is_module) \
    i_prop    (X,Y, public,     bool,                   is_static) \
    i_prop    (X,Y, public,     bool,                   is_require) \
    i_prop    (X,Y, public,     bool,                   is_inlay) \
    i_prop    (X,Y, public,     bool,                   is_const) \
    i_prop    (X,Y, public,     bool,                   is_assigned) \
    i_prop    (X,Y, public,     bool,                   is_type) \
    i_prop    (X,Y, public,     bool,                   is_func) \
    i_prop    (X,Y, public,     bool,                   is_arg) \
    i_prop    (X,Y, public,     bool,                   is_decl) \
    i_prop    (X,Y, public,     path,                   from_include) \
    i_prop    (X,Y, public,     object,                 initializer) \
    i_prop    (X,Y, intern,     i64,                    offset) \
    i_prop    (X,Y, intern,     i64,                    index) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        debug) \
    i_method  (X,Y, public,     bool,    has_value) \
    i_method  (X,Y, public,     none,    set_model,     model) \
    i_method  (X,Y, public,     none,    set_value,     object) \
    i_method  (X,Y, public,     member,  resolve,       string) \
    i_override(X,Y, method,     init)
#ifndef member_intern
#define member_intern isize(member)
#endif
declare_mod(member, node)


#define code_schema(X,Y) \
    i_prop    (X,Y, intern, LLVMBasicBlockRef, block) \
    i_prop    (X,Y, public, ether,  mod) \
    i_prop    (X,Y, public, symbol, label) \
    i_method  (X,Y, public, none,   select) \
    i_override(X,Y, method, init)
#ifndef code_intern
#define code_intern isize(code)
#endif
declare_class(code)

#define ether_schema(X,Y)\
    i_prop    (X,Y, required,   path,                   source) \
    i_prop    (X,Y, required,   string,                 lang) \
    i_prop    (X,Y, required,   path,                   install) \
    i_prop    (X,Y, public,     bool,                   delegate) \
    i_prop    (X,Y, public,     bool,                   no_build) \
    i_prop    (X,Y, public,     bool,                   with_debug) \
    i_prop    (X,Y, intern,     path,                   current_include) \
    i_prop    (X,Y, intern,     function,               current_fn) \
    i_prop    (X,Y, public,     model,                  top) \
    i_prop    (X,Y, public,     array,                  lex) \
    i_prop    (X,Y, public,     map,                    base) \
    i_prop    (X,Y, intern,     LLVMExecutionEngineRef, jit) \
    i_prop    (X,Y, intern,     LLVMBasicBlockRef,      current_if_block) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module) \
    i_prop    (X,Y, intern,     LLVMContextRef,         module_ctx) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg_builder) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine) \
    i_prop    (X,Y, intern,     cstr,                   target_triple) \
    i_prop    (X,Y, public,     bool,                   left_hand) \
    i_method  (X,Y, public,     node,       default_value, model) \
    i_method  (X,Y, public,     node,       builder, subprocedure) \
    i_method  (X,Y, public,     none,       build_initializer, function) \
    i_method  (X,Y, public,     node,       eelement,   node, object) \
    i_method  (X,Y, public,     none,       ecmp,       node, comparison, node, code, code) \
    i_method  (X,Y, public,     none,       ebranch,    code) \
    i_method  (X,Y, public,     member,     compatible,     record, string, AFlag, array) \
    i_method  (X,Y, public,     none,       push_member,    member) \
    i_method  (X,Y, public,     member,     push_model,     model) \
    i_method  (X,Y, public,     node,       operand,        object, model) \
    i_method  (X,Y, public,     node,       op,             OPType, string, object, object) \
    i_method  (X,Y, public,     node,       load,           member) \
    i_method  (X,Y, public,     node,       offset,         node, object) \
    i_method  (X,Y, public,     node,       if_else,        array, array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     node,       ternary,        node, node, node) \
    i_method  (X,Y, public,     node,       convert,        node, model) \
    i_method  (X,Y, public,     node,       addr_of,        node, model) \
    i_method  (X,Y, public,     node,       bitwise_not,    node) \
    i_method  (X,Y, public,     node,       not,            node) \
    i_method  (X,Y, public,     none,       einc,           node, num) \
    i_method  (X,Y, public,     none,       eprint_node,    node) \
    i_method  (X,Y, public,     member,     evar,           model, string) \
    i_method  (X,Y, public,     node,       or,             object, object) \
    i_method  (X,Y, public,     node,       xor,            object, object) \
    i_method  (X,Y, public,     node,       and,            object, object) \
    i_method  (X,Y, public,     node,       add,            object, object) \
    i_method  (X,Y, public,     node,       sub,            object, object) \
    i_method  (X,Y, public,     node,       mul,            object, object) \
    i_method  (X,Y, public,     node,       div,            object, object) \
    i_method  (X,Y, public,     node,       create,          model, object) \
    i_method  (X,Y, public,     node,       zero,           node) \
    i_method  (X,Y, public,     node,       assign,         node,   object, OPType) \
    i_method  (X,Y, public,     node,       eq,             node, node) \
    i_method  (X,Y, public,     node,       cmp,            node, node) \
    i_method  (X,Y, public,     node,       not_eq,         node, node) \
    i_method  (X,Y, public,     node,       fn_call,        member, array) \
    i_method  (X,Y, public,     node,       fn_return,      object) \
    i_method  (X,Y, public,     node,       is,             node, object) \
    i_method  (X,Y, public,     node,       inherits,       node, object) \
    i_method  (X,Y, public,     member,     lookup,         object, AType) \
    i_method  (X,Y, public,     model,      context_model,  AType) \
    i_method  (X,Y, public,     none,       include,        string) \
    i_method  (X,Y, public,     none,       llflag,         symbol, i32) \
    i_method  (X,Y, public,     model,      push,     model) \
    i_method  (X,Y, public,     model,      pop) \
    i_method  (X,Y, public,     model,      top) \
    i_method  (X,Y, public,     none,       write) \
    i_method  (X,Y, public,     model,      return_type) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
#ifndef ether_intern
#define ether_intern isize(ether)
#endif
declare_mod(ether, model)

// i_vargs   (X,Y, public,     none,       eprint,         symbol) \

bool is_void     (model);
bool is_bool     (model);
bool is_float    (model);
bool is_double   (model);
bool is_realistic(model);
bool is_integral (model);
bool is_signed   (model);
bool is_unsigned (model);
bool is_record   (model);
bool is_generic  (model);
bool is_class    (model);
bool is_enumerable(model);
bool is_struct   (model);
bool is_ref      (model);

#endif