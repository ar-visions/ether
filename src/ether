#ifndef _SILVER_
#define _SILVER_

#include <A>
#include <ether-classes>

/// @brief the ether should be considered mysterious, and magical.
/// because nobody can retain information on what LLVM does, due to 
/// the multiple APIs you must employ simultaneously.
/// we internal those members, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct ether*       ether;
typedef struct value*       value;
typedef struct member*      member;
typedef struct function*    function;

#define interface_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(interface)

#define model_schema(X,Y) \
    enum_value(X,Y, bool)  \
    enum_value(X,Y, u8)  \
    enum_value(X,Y, u16) \
    enum_value(X,Y, u32) \
    enum_value(X,Y, u64) \
    enum_value(X,Y, i8)  \
    enum_value(X,Y, i16) \
    enum_value(X,Y, i32) \
    enum_value(X,Y, i64) \
    enum_value(X,Y, f32) \
    enum_value(X,Y, f64) \
    enum_value(X,Y, cstr) \
    enum_value(X,Y, void) \
    enum_value(X,Y, union) \
    enum_value(X,Y, struct) \
    enum_value(X,Y, class) \
    enum_value(X,Y, function) \
    enum_value(X,Y, typedef)
declare_enum(model)

/// the base helps us require the two args we need for nodes

#define node_schema(X,Y)\
    i_prop    (X,Y, public,     string,                 name) \
    i_prop    (X,Y, required,   ether,                  mod) \
    i_prop    (X,Y, intern,     LLVMValueRef,           value)
#ifndef node_intern
#define node_intern
#endif
declare_class(node)

// support 'target' as optional 
// (we are just using first argument, and assuming not given in args!)
#define fcall_schema(X,Y) \
    i_prop(X,Y, required,     function,               addr) \
    i_prop(X,Y, required,     map,                    args) \
    i_prop(X,Y, public,       member,                 target)
#ifndef fcall_intern
#define fcall_intern
#endif
declare_mod(fcall, node)

#define op_schema(X,Y) \
    i_prop(X,Y, required,     OPType,       optype) \
    i_prop(X,Y, required,     node,         left) \
    i_prop(X,Y, public,       node,         right)
#ifndef op_intern
#define op_intern
#endif
declare_mod(op, node)


#define ret_schema(X,Y)
#ifndef ret_intern
#define ret_intern
#endif
declare_mod(ret, node)


#define def_schema(X,Y) \
    i_prop(    X,Y, public,     interface,              access) \
    i_prop(    X,Y, public,     AType,                  imported) \
    i_prop(    X,Y, public,     model,                  mdl) \
    i_prop(    X,Y, public,     function,               function) \
    i_prop(    X,Y, public,     i64,                    flags) \
    i_prop(    X,Y, public,     member,                 origin) \
    i_prop(    X,Y, public,     i32,                    size) \
    i_prop(    X,Y, public,     map,                    members) \
    i_prop(    X,Y, intern,     LLVMTypeRef,            type) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_override(X,Y, method,     init)
#ifndef def_intern
#define def_intern
#endif
declare_mod(def, node)


#define function_schema(X,Y) \
    i_prop(    X,Y, public,     bool,                   va_args) \
    i_prop(    X,Y, public,     map,                    args) \
    i_prop(    X,Y, public,     def,                    def) \
    i_prop(    X,Y, public,     def,                    target) \
    i_prop(    X,Y, public,     member,                 rtype) \
    i_prop(    X,Y, public,     subprocedure,           builder) \
    i_prop(    X,Y, intern,     LLVMScope,              scope) \
    i_prop(    X,Y, intern,     LLVMBasicBlockRef,      entry)
#ifndef function_intern
#define function_intern
#endif
declare_mod(function, node)


#define member_schema(X,Y) \
    i_prop(    X,Y, public,     def,                    def) \
    i_prop(    X,Y, public,     map,                    context) \
    i_prop(    X,Y, intern,     num,                    depth) \
    i_prop(    X,Y, intern,     bool,                   is_static) \
    i_prop(    X,Y, intern,     bool,                   is_const) \
    i_prop(    X,Y, intern,     interface,              access) \
    i_prop(    X,Y, intern,     def,                    wrap) \
    i_prop(    X,Y, intern,     array,                  shape) \
    i_prop(    X,Y, intern,     bool,                   cached) \
    i_prop(    X,Y, intern,     LLVMTypeRef,            type) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_prop(    X,Y, public,     num,                    line) \
    i_override(X,Y, method,     init)
#ifndef member_intern
#define member_intern
#endif
declare_mod(member, node)

/// ether must be capable of multiple returns in abstract
/// this is something i believe we require of silver for 0.88 spec
#define ether_schema(X,Y)\
    i_prop    (X,Y, required,   string,                 name) \
    i_prop    (X,Y, public,     string,                 lang) \
    i_prop    (X,Y, public,     path,                   install) \
    i_method  (X,Y, public,     def,  function,         cstr, def, member, map, bool, subprocedure) \
    i_method  (X,Y, public,     node, op,               OPType, object, object) \
    i_method  (X,Y, public,     node, add,              object, object) \
    i_method  (X,Y, public,     node, sub,              object, object) \
    i_method  (X,Y, public,     node, mul,              object, object) \
    i_method  (X,Y, public,     node, div,              object, object) \
    i_method  (X,Y, public,     node, fcall,            function, member, map) \
    i_method  (X,Y, public,     node, freturn,          object) \
    i_method  (X,Y, public,     node, push_members) \
    i_method  (X,Y, public,     node, pop_members) \
    i_prop    (X,Y, required,   path,                   source) \
    i_prop    (X,Y, intern,     path,                   current_include) \
    i_prop    (X,Y, intern,     function,               current_fn) \
    i_prop    (X,Y, intern,     array,                  members) \
    i_prop    (X,Y, intern,     map,                    defs) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module) \
    i_prop    (X,Y, intern,     LLVMContextRef,         context) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg) \
    i_prop    (X,Y, intern,     LLVMScope,              scope) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine) \
    i_prop    (X,Y, intern,     cstr,                   target_triple) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
#ifndef ether_intern
#define ether_intern
#endif
declare_class(ether)

#endif