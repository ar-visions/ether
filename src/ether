#ifndef _ETHER_
#define _ETHER_

#include <A>

/// @brief the ether should be considered mysterious, and magical.
/// to make effective debuggable LL code, one has to employ multiple 
/// APIs simultaneously (IR & DBG) and its easy for that to take 
/// over the syntax

/// we internalize LLVM here, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct ether*       ether;
typedef struct model*       model;
typedef struct member*      member;

#define token_schema(X,Y) \
    i_prop      (X,Y,  required, cstr,      chars) \
    i_prop      (X,Y,  public,  sz,         len) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  A,          literal) \
    i_method    (X,Y,  public,  AType,      get_type) \
    i_method    (X,Y,  public,  bool,       eq,         cstr) \
    i_method    (X,Y,  public,  num,        cmp,        cstr) \
    i_method    (X,Y,  public,  sz,         len) \
    i_method    (X,Y,  public,  string,     location) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  compare) \
    i_override  (X,Y,  cast,    string) \
    i_override  (X,Y,  cast,    bool) \
    i_override  (X,Y,  method,  init)
#ifndef token_intern
#define token_intern
#endif
declare_class(token)


#define interface_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(interface)


#define reference_schema(X,Y) \
    enum_value(X,Y, value) \
    enum_value(X,Y, pointer) \
    enum_value(X,Y, constant)
declare_enum(reference)


#define model_schema(X,Y)\
    i_prop    (X,Y, required,   ether,            mod) \
    i_prop    (X,Y, public,     token,            name) \
    i_prop    (X,Y, required,   object,           src) \
    i_prop    (X,Y, public,     reference,        ref) \
    i_prop    (X,Y, public,     array,            shape) \
    i_prop    (X,Y, public,     sz,               size) \
    i_prop    (X,Y, public,     sz,               alignment) \
    i_prop    (X,Y, public,     subprocedure,     completer) \
    i_prop    (X,Y, public,     model,            rtype) \
    i_prop    (X,Y, public,     map,              members) \
    i_prop    (X,Y, intern,     LLVMScope,        scope) \
    i_prop    (X,Y, intern,     LLVMTypeRef,      type) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,  debug) \
    i_method  (X,Y, public,     model, alias,     string, reference, array) \
    i_method  (X,Y, public,     i64, cmp,         model) \
    i_override(X,Y, method,     init)
#ifndef model_intern
#define model_intern isize(model)
#endif
declare_class(model)


#define function_schema(X,Y) \
    i_prop(X,Y, public,     bool,                   is_instance) \
    i_prop(X,Y, public,     bool,                   is_cast) \
    i_prop(X,Y, public,     bool,                   va_args) \
    i_prop(X,Y, public,     array,                  args) \
    i_prop(X,Y, public,     model,                  record) \
    i_prop(X,Y, public,     member,                 target) \
    i_prop(X,Y, intern,     LLVMBasicBlockRef,      entry) \
    i_prop(X,Y, intern,     LLVMValueRef,           value) \
    i_override(X,Y, method, init)
#ifndef function_intern
#define function_intern isize(function)
#endif
declare_mod(function, model)



#define non_registered_schema(X,Y)
#ifndef non_registered_intern
#define non_registered_intern isize(non_registered)
#endif
declare_mod(non_registered, model)

// for each field, f_* name-bound class, enum or primitive
#define record_schema(X,Y) \
    i_prop(X,Y, public,   record,       parent) \
    i_override(X,Y, method, init)
#ifndef record_intern
#define record_intern
#endif
declare_mod(record, model)





#define class_schema(X,Y)
#ifndef class_intern
#define class_intern
#endif
declare_mod(class, record, model)

#define structure_schema(X,Y)
#ifndef structure_intern
#define structure_intern
#endif
declare_mod(structure, record, model)


/// the base helps us require the two args we need for nodes
/// we are also coupling type along inside node, and this must be set properly with value macro
/// all node values must contain its ether def.
/// otherwise we are performing hash lookups, which is more complex and slower, 
/// with less data stored
#define node_schema(X,Y)\
    i_prop    (X,Y, public,     token,                  name) \
    i_prop    (X,Y, public,     ether,                  mod) \
    i_prop    (X,Y, required,   model,                  mdl) \
    i_prop    (X,Y, public,     num,                    line) \
    i_prop    (X,Y, public,     num,                    column) \
    i_prop    (X,Y, intern,     LLVMValueRef,           value)
#ifndef node_intern
#define node_intern isize(node)
#endif
declare_class(node)

// if ref is set, its a reference to a member with type definition (model, struct, ref)
#define member_schema(X,Y) \
    i_prop    (X,Y, public,     interface,              access) \
    i_prop    (X,Y, public,     bool,                   is_static) \
    i_prop    (X,Y, public,     bool,                   is_const) \
    i_prop    (X,Y, public,     bool,                   is_assigned) \
    i_prop    (X,Y, public,     bool,                   is_type) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        debug) \
    i_override(X,Y, method,     init)
#ifndef member_intern
#define member_intern isize(member)
#endif
declare_mod(member, node)


// support 'target' as optional 
// (we are just using first argument, and assuming not given in args!)
#define fcall_schema(X,Y) \
    i_prop(X,Y, required,     member,                 fn) \
    i_prop(X,Y, required,     map,                    args) \
    i_prop(X,Y, public,       member,                 target)
#ifndef fcall_intern
#define fcall_intern
#endif
declare_mod(fcall, node)


#define op_schema(X,Y) \
    i_prop(X,Y, required,     OPType,       optype) \
    i_prop(X,Y, required,     node,         left) \
    i_prop(X,Y, public,       node,         right)
#ifndef op_intern
#define op_intern
#endif
declare_mod(op, node)


#define ret_schema(X,Y)
#ifndef ret_intern
#define ret_intern
#endif
declare_mod(ret, node)


/// ether must be capable of multiple returns in abstract
/// this is something i believe we require of silver for 0.88 spec
#define ether_schema(X,Y)\
    i_prop    (X,Y, required,   path,                   source) \
    i_prop    (X,Y, public,     string,                 lang) \
    i_prop    (X,Y, public,     path,                   install) \
    i_method  (X,Y, public,     none,       push_member, member) \
    i_method  (X,Y, public,     member,     function,   token, model, bool, model, array, bool, subprocedure) \
    i_method  (X,Y, public,     node,       op,         OPType, string, object, object) \
    i_method  (X,Y, public,     node,       load,       node, model, object) \
    i_method  (X,Y, public,     node,       if_else,    array, array, subprocedure, subprocedure) \
    i_method  (X,Y, public,     node,       convert,    node, model) \
    i_method  (X,Y, public,     node,       addr_of,    node, model) \
    i_method  (X,Y, public,     node,       bitwise_not, node) \
    i_method  (X,Y, public,     node,       not,        node) \
    i_method  (X,Y, public,     node,       or,         object, object) \
    i_method  (X,Y, public,     node,       xor,        object, object) \
    i_method  (X,Y, public,     node,       and,        object, object) \
    i_method  (X,Y, public,     node,       add,        object, object) \
    i_method  (X,Y, public,     node,       sub,        object, object) \
    i_method  (X,Y, public,     node,       mul,        object, object) \
    i_method  (X,Y, public,     node,       div,        object, object) \
    i_method  (X,Y, public,     node,       assign,     node,   object) \
    i_method  (X,Y, public,     node,       assign_add, node,   object) \
    i_method  (X,Y, public,     node,       assign_sub, node,   object) \
    i_method  (X,Y, public,     node,       assign_mul, node,   object) \
    i_method  (X,Y, public,     node,       assign_div, node,   object) \
    i_method  (X,Y, public,     node,       assign_mod, node,   object) \
    i_method  (X,Y, public,     node,       assign_or,  node,   object) \
    i_method  (X,Y, public,     node,       assign_and, node,   object) \
    i_method  (X,Y, public,     node,       assign_xor, node,   object) \
    i_method  (X,Y, public,     node,       eq,         node, node) \
    i_method  (X,Y, public,     node,       not_eq,     node, node) \
    i_method  (X,Y, public,     node,       literal,    object) \
    i_method  (X,Y, public,     node,       fcall,      member, node, array) \
    i_method  (X,Y, public,     node,       freturn,    object) \
    i_method  (X,Y, public,     node,       is,         node, object) \
    i_method  (X,Y, public,     node,       inherits,   node, object) \
    i_method  (X,Y, public,     member,     lookup,     string) \
    i_method  (X,Y, public,     model,      push,       model) \
    i_method  (X,Y, public,     model,      pop) \
    i_method  (X,Y, public,     model,      top) \
    i_method  (X,Y, public,     none,       write) \
    i_method  (X,Y, public,     model,      return_type) \
    i_method  (X,Y, public,     model,      context_model, AType) \
    i_prop    (X,Y, intern,     path,                   current_include) \
    i_prop    (X,Y, intern,     function,               current_fn) \
    i_prop    (X,Y, public,     model,                  top) \
    i_prop    (X,Y, intern,     array,                  lex) \
    i_prop    (X,Y, public,     map,                    base) \
    i_prop    (X,Y, intern,     LLVMBasicBlockRef,      current_if_block) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module) \
    i_prop    (X,Y, intern,     LLVMContextRef,         module_ctx) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg_builder) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine) \
    i_prop    (X,Y, intern,     cstr,                   target_triple) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
#ifndef ether_intern
#define ether_intern isize(ether)
#endif
declare_mod(ether, model)

bool is_bool     (member);
bool is_float    (member);
bool is_double   (member);
bool is_realistic(member);
bool is_integral (member);
bool is_signed   (member);
bool is_unsigned (member);
bool is_object   (member);
bool is_class    (member);
bool is_struct   (member);
bool is_ref      (member);

#endif