#ifndef _ETHER_
#define _ETHER_

#include <A>

/// @brief the ether should be considered mysterious, and magical.
/// because nobody can retain information on what LLVM does, due to 
/// the multiple APIs you must employ simultaneously.
/// we internal those members, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct ether*       ether;
typedef struct type*        type;
typedef struct member*      member;
typedef struct function*    function;

#define token_schema(X,Y) \
    i_prop      (X,Y,  required, cstr,      chars) \
    i_prop      (X,Y,  public,  sz,         len) \
    i_prop      (X,Y,  public,  path,       source) \
    i_prop      (X,Y,  public,  num,        line) \
    i_prop      (X,Y,  public,  num,        column) \
    i_prop      (X,Y,  public,  A,          literal) \
    i_method    (X,Y,  public,  AType,      get_type) \
    i_method    (X,Y,  public,  bool,       eq,         cstr) \
    i_method    (X,Y,  public,  num,        cmp,        cstr) \
    i_method    (X,Y,  public,  sz,         len) \
    i_override  (X,Y,  method,  init) \
    i_override  (X,Y,  method,  compare) \
    i_override  (X,Y,  cast,    string) \
    i_override  (X,Y,  cast,    bool) \
    i_override  (X,Y,  method,  init)
#ifndef token_intern
#define token_intern
#endif
declare_class(token)


#define interface_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(interface)


#define model_schema(X,Y) \
    enum_value(X,Y, bool)  \
    enum_value(X,Y, u8)  \
    enum_value(X,Y, u16) \
    enum_value(X,Y, u32) \
    enum_value(X,Y, u64) \
    enum_value(X,Y, i8)  \
    enum_value(X,Y, i16) \
    enum_value(X,Y, i32) \
    enum_value(X,Y, i64) \
    enum_value(X,Y, f32) \
    enum_value(X,Y, f64) \
    enum_value(X,Y, void) \
    enum_value(X,Y, union) \
    enum_value(X,Y, struct) \
    enum_value(X,Y, class) \
    enum_value(X,Y, function) \
    enum_value(X,Y, typedef)
declare_enum(model)

#ifndef LLVM_VERSION_MAJOR
/// we may not have internal members in poly
typedef void* LLVMValueRef;
typedef void* LLVMTypeRef;
typedef void* LLVMScope;
#endif


#define context_schema(X,Y)\
    i_prop    (X,Y, intern,     LLVMScope,              scope) \
    i_prop    (X,Y, intern,     type,                   rtype) \
    i_prop    (X,Y, intern,     map,                    members) \
    i_override(X,Y, method,     init)
#ifndef context_intern
#define context_intern
#endif
declare_class(context)


/// the base helps us require the two args we need for nodes
#define node_schema(X,Y)\
    i_prop    (X,Y, public,     token,                  name) \
    i_prop    (X,Y, public,     ether,                  mod) \
    i_prop    (X,Y, public,     LLVMValueRef,           value)
#ifndef node_intern
#define node_intern
#endif
declare_class(node)


#define type_schema(X,Y) \
    i_prop(    X,Y, public,     map,                    members) \
    i_prop(    X,Y, public,     function,               function) \
    i_prop(    X,Y, intern,     LLVMTypeRef,            ref) \
    i_prop(    X,Y, public,     bool,                   is_const) \
    i_prop(    X,Y, intern,     type,                   wrap) \
    i_prop(    X,Y, intern,     num,                    depth) \
    i_prop(    X,Y, public,     interface,              access) \
    i_prop(    X,Y, public,     AType,                  imported) \
    i_prop(    X,Y, public,     model,                  mdl) \
    i_prop(    X,Y, public,     map,                    attribs) \
    i_prop(    X,Y, public,     type,                   origin) \
    i_prop(    X,Y, public,     i32,                    size) \
    i_prop(    X,Y, intern,     array,                  shape) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_prop(    X,Y, public,     num,                    line) \
    i_method(  X,Y, public,     type, create_ref) \
    i_override(X,Y, method,     init)
#ifndef type_intern
#define type_intern
#endif
declare_mod(type, node)


#define member_schema(X,Y) \
    i_prop(    X,Y, public,     bool,                   is_ref) \
    i_prop(    X,Y, public,     bool,                   is_static) \
    i_prop(    X,Y, public,     bool,                   is_const) \
    i_prop(    X,Y, public,     bool,                   is_assigned) \
    i_prop(    X,Y, public,     bool,                   is_function) \
    i_prop(    X,Y, required,   type,                   type) \
    i_prop(    X,Y, intern,     interface,              access) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_override(X,Y, method,     init)
#ifndef member_intern
#define member_intern
#endif
declare_mod(member, node)


#define function_schema(X,Y) \
    i_prop(    X,Y, public,     bool,                   va_args) \
    i_prop(    X,Y, public,     map,                    args) \
    i_prop(    X,Y, public,     type,                   type) \
    i_prop(    X,Y, public,     type,                   target) \
    i_prop(    X,Y, public,     type,                   rtype) \
    i_prop(    X,Y, public,     subprocedure,           builder) \
    i_prop(    X,Y, intern,     LLVMScope,              scope) \
    i_prop(    X,Y, intern,     LLVMBasicBlockRef,      entry)
#ifndef function_intern
#define function_intern
#endif
declare_mod(function, node)


// support 'target' as optional 
// (we are just using first argument, and assuming not given in args!)
#define fcall_schema(X,Y) \
    i_prop(X,Y, required,     function,               addr) \
    i_prop(X,Y, required,     map,                    args) \
    i_prop(X,Y, public,       member,                 target)
#ifndef fcall_intern
#define fcall_intern
#endif
declare_mod(fcall, node)


#define op_schema(X,Y) \
    i_prop(X,Y, required,     OPType,       optype) \
    i_prop(X,Y, required,     node,         left) \
    i_prop(X,Y, public,       node,         right)
#ifndef op_intern
#define op_intern
#endif
declare_mod(op, node)


#define ret_schema(X,Y)
#ifndef ret_intern
#define ret_intern
#endif
declare_mod(ret, node)


/// ether must be capable of multiple returns in abstract
/// this is something i believe we require of silver for 0.88 spec
#define ether_schema(X,Y)\
    i_prop    (X,Y, required,   string,                 name) \
    i_prop    (X,Y, public,     string,                 lang) \
    i_prop    (X,Y, public,     path,                   install) \
    i_method  (X,Y, public,     type,       function,   cstr, type, type, map, bool, subprocedure) \
    i_method  (X,Y, public,     node,       op,         OPType, object, object) \
    i_method  (X,Y, public,     node,       add,        object, object) \
    i_method  (X,Y, public,     node,       sub,        object, object) \
    i_method  (X,Y, public,     node,       mul,        object, object) \
    i_method  (X,Y, public,     node,       div,        object, object) \
    i_method  (X,Y, public,     node,       assign_add, object, object) \
    i_method  (X,Y, public,     node,       assign_sub, object, object) \
    i_method  (X,Y, public,     node,       assign_mul, object, object) \
    i_method  (X,Y, public,     node,       assign_div, object, object) \
    i_method  (X,Y, public,     node,       eq,         node, node) \
    i_method  (X,Y, public,     node,       not_eq,     node, node) \
    i_method  (X,Y, public,     node,       fcall,      function, member, map) \
    i_method  (X,Y, public,     node,       freturn,    object) \
    i_method  (X,Y, public,     member,     lookup,     string) \
    i_method  (X,Y, public,     context,    push) \
    i_method  (X,Y, public,     context,    pop) \
    i_method  (X,Y, public,     context,    top) \
    i_method  (X,Y, public,     none,       write) \
    i_prop    (X,Y, required,   path,                   source) \
    i_prop    (X,Y, intern,     path,                   current_include) \
    i_prop    (X,Y, intern,     function,               current_fn) \
    i_prop    (X,Y, intern,     context,                top) \
    i_prop    (X,Y, intern,     array,                  lex) \
    i_prop    (X,Y, intern,     map,                    defs) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module) \
    i_prop    (X,Y, intern,     LLVMContextRef,         module_ctx) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg) \
    i_prop    (X,Y, intern,     LLVMScope,              scope) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine) \
    i_prop    (X,Y, intern,     cstr,                   target_triple) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
#ifndef ether_intern
#define ether_intern
#endif
declare_class(ether)

#define LLVMValueRef_schema(X,Y) raw_schema(X,Y)
declare_primitive(LLVMValueRef, raw)

#endif