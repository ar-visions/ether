#ifndef _SILVER_
#define _SILVER_

#include <A>
#include <ether-classes>

/// @brief the ether should be considered mysterious, and magical.
/// because nobody can retain information on what LLVM does, due to 
/// the multiple APIs you must employ simultaneously.
/// we internal those members, and what we expose is simple bindings
/// by A-type driven types.  its just how you want to 'start' building
/// a language, like silver!

typedef struct ether*       ether;
typedef struct value*       value;
typedef struct member*      member;
typedef struct function*    function;

#define interface_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(interface)

#define model_schema(X,Y) \
    enum_value(X,Y, bool)  \
    enum_value(X,Y, u8)  \
    enum_value(X,Y, u16) \
    enum_value(X,Y, u32) \
    enum_value(X,Y, u64) \
    enum_value(X,Y, i8)  \
    enum_value(X,Y, i16) \
    enum_value(X,Y, i32) \
    enum_value(X,Y, i64) \
    enum_value(X,Y, f32) \
    enum_value(X,Y, f64) \
    enum_value(X,Y, cstr) \
    enum_value(X,Y, void) \
    enum_value(X,Y, union) \
    enum_value(X,Y, struct) \
    enum_value(X,Y, class) \
    enum_value(X,Y, function) \
    enum_value(X,Y, typedef)
declare_enum(model)

#define value_schema(X,Y) \
    i_prop(    X,Y, required,     object,                 param) \
    i_prop(    X,Y, intern,       LLVMValueRef,           vr)
declare_class(value)

// support 'target' as optional
#define fcall_schema(X,Y) \
    i_prop(    X,Y, required,     function,               addr) \
    i_prop(    X,Y, required,     map,                    args) \
    i_prop(    X,Y, public,       value,                  target)
declare_class(fcall)

#define add_schema(X,Y) \
    i_prop(    X,Y, required,     value,                  left) \
    i_prop(    X,Y, required,     value,                  right)
declare_class(add)

#define sub_schema(X,Y) add_schema(X,Y)
declare_class(sub)

#define mul_schema(X,Y) add_schema(X,Y)
declare_class(mul)

#define div_schema(X,Y) add_schema(X,Y)
declare_class(div)

#define ret_schema(X,Y) \
    i_prop(    X,Y, required, value,        val) \
    i_prop(    X,Y, intern,   LLVMValueRef, vr)
declare_class(ret)

/// the base helps us require the two args we need for nodes
#define node_schema(X,Y)\
    i_prop    (X,Y, required,   string,                 name) \
    i_prop    (X,Y, required,   ether,                  mod)
declare_class(node)

#define def_schema(X,Y) \
    i_prop(    X,Y, public,     interface,              access) \
    i_prop(    X,Y, public,     model,                  mdl) \
    i_prop(    X,Y, public,     AType,                  imported) \
    i_prop(    X,Y, public,     i64,                    flags) \
    i_prop(    X,Y, public,     member,                 origin) \
    i_prop(    X,Y, public,     i32,                    size) \
    i_prop(    X,Y, public,     map,                    members) \
    i_prop(    X,Y, intern,     LLVMTypeRef,            type) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_override(X,Y, method,     init)
declare_mod(def, node)

#define function_schema(X,Y) \
    i_prop(    X,Y, public,     bool,                   va_args) \
    i_prop(    X,Y, public,     map,                    args) \
    i_prop(    X,Y, public,     def,                    def) \
    i_prop(    X,Y, public,     member,                 rtype) \
    i_prop(    X,Y, public,     object,                 content) \
    i_prop(    X,Y, intern,     LLVMScope,              scope) \
    i_prop(    X,Y, intern,     LLVMBasicBlockRef,      entry) \
    i_override(X,Y, method,     init)
declare_mod(function, node)

#define member_schema(X,Y) \
    i_prop(    X,Y, public,     def,                    def) \
    i_prop(    X,Y, public,     map,                    context) \
    i_prop(    X,Y, intern,     num,                    depth) \
    i_prop(    X,Y, intern,     bool,                   is_static) \
    i_prop(    X,Y, intern,     bool,                   is_const) \
    i_prop(    X,Y, intern,     interface,              access) \
    i_prop(    X,Y, intern,     def,                    wrap) \
    i_prop(    X,Y, intern,     array,                  shape) \
    i_prop(    X,Y, intern,     bool,                   cached) \
    i_prop(    X,Y, intern,     LLVMTypeRef,            type) \
    i_prop(    X,Y, intern,     LLVMValueRef,           value) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,        dbg) \
    i_prop(    X,Y, public,     num,                    line) \
    i_override(X,Y, method,     init)
declare_mod(member, node)

#define ether_schema(X,Y)\
    i_prop    (X,Y, required,   string,                 name) \
    i_prop    (X,Y, intern,     map,                    defs) \
    i_prop    (X,Y, intern,     LLVMModuleRef,          module) \
    i_prop    (X,Y, intern,     LLVMContextRef,         context) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,         builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,        compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,       dbg) \
    i_prop    (X,Y, intern,     LLVMScope,              scope) \
    i_prop    (X,Y, intern,     LLVMTargetRef,          target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,      target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef,   target_machine) \
    i_prop    (X,Y, intern,     cstr,                   target_triple) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
declare_class(ether)

#endif